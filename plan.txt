
pretty print as3 so I can read it and understand what's happening
write some as3, compile it, and look at the output

translate basic ruby calls to as3
insert byte codes into existing abc_file
- have to search/update constant_pool - strings, multinames, namespaces

goals:
- enable code generation from Ruby to AS3 bytecode
-- implement methods and event handlers
-- shortcuts for properties and handling changes in commitProperties()
-- automatic xxChanged:boolean generation and callback in commitProperties() based on some convention
- enable tx of Flash vector definitions
-- transform vectors into Degrafa definitions
- transform fonts into Degrafa definitions
- pointcut expressions to modify existing methods

Awful things I don't want to think about:
* converting floating point numbers


New plans:

* Implement a bunch of AS3 to support Ruby
* Implement different send_external on Object.prototype and RObject.prototype
* Don't use AS3 classes to implement Ruby classes
* Ruby inheritance hierarchy implemented in plain AS3 to support proper semantics and method dispatch

Problems:
* How do you "subclass" Sprite; implement a Sprite object in Ruby if you cannot inherit from flash.display.Sprite?
* method for proxying a typed class? include_typed_class Flash::Display::Sprite


Const (and other) scoping issues:

Here's the code in question:

class A
  class B
    def d
      C
    end
  end
  class C
  end
end

b = A::B.new
b.d # returns A::C

How does this work? The :getconstant bytecode searches upwards in the scope
stack at the time of definition to find the constant. When I define classes
and methods, I'm not saving the scope stack currently so I don't know where
to search for the constant definition.

Solution: Obviously, the scope stack must be searched by this opcode and
others. Is there a way to call up the scope stack that is created by AVM2?

Looks like it is very hard to use the Flash call stack to look up this
information. Decent solution is to store the call stack at each level, but
where would this actually be stored? Then would local variables not really
be local variables in the AS3 version? It seems like we are getting further
and further away from a bytecode translater into a bytecode interpretter
at this point. Is this a good idea?

We have closures already in Flash, but do the opcodes for accessing closure
variables allow us to translate into something that can be used in AS3?
What are the opcodes in AS3 also?

10/8/2008

Moved test/files which are not used in tests to /research. This seems like
a more appropriate and descriptive name.

10/9/2008


"YARVInstructionSequence/SimpleDataFormat", 1, 1, 1,
{:arg_size=>1, :local_size=>5, :stack_max=>2},
"blah", "<compiled>",
:method,
[:parm1, :i, :i2, :ar],
1,
[
  [:break, nil, :label_32, :label_40, :label_40, 0],
  [:break, nil, :label_41, :label_49, :label_49, 0],
  [:break, nil, :label_50, :label_58, :label_58, 0],
]


10/14/2008

Migrating Red Sun work to new MacBook Pro. Authorizing github access and 
testing commit privileges. Installing Ruby 1.9.0-4, looking into mspec instead
of rspec.

Making new plan for conference deadline:

Focus on establishing baseline through generating as3. Accept the possibility
that storing stack information may be necessary fo lookups. May need a
structure for stack information. Use HotRuby as a guide. Get into the Ruby
source further and track down the execution of the bytecode.

Using anonymous functions as block scope might work. Pass the surrounding
blocks structure as a parameter to the function as in:

// root
function ():* {
  scope = new Scope();
  // blah
  function (upper:Scope):* {
    scope = new Scope(upper);
    // blah
    scope.getdynamic(/* ?? */);
  }();
}


Tracing initial ruby execution:
main.c:23
main(int argc, char **argv)
 ruby_set_debug_option(getenv("RUBY_DEBUG"))
 ruby_sysinit(&argc, &argv)
 ruby_run_node(ruby_options(argc, argv))

eval.c:233
ruby_run_node(VALUE n)
 Init_stack(n)
 ruby_cleanup(ruby_exec_node(n, 0))

eval.c:207
ruby_exec_node(VALUE n, char *file):
 PUSH_TAG()
 EXEC_TAG()
 rb_iseq_eval(n)
 POP_TAG()
 return state

vm.c:1256
rb_iseq_eval(VALUE iseqval)
 vm_set_top_stack(GET_THREAD(), iseqval)
 rb_define_global_const("TOPLEVEL_BINDING", rb_binding_new())
 return vm_eval_body(th)

vm.c:1051
vm_eval_body(rb_thread_t *th)
 TH_PUSH_TAG(th)
 state = EXEC_TAG()
 result = vm_eval(th, initial)
 if (th->state != 0) goto exception_handler
  COMPLICATED EXCEPTION HANDLING
 TH_POP_TAG()
 return result

vm_core.h:343
typedef struct {
    VALUE *pc;			/* cfp[0] */
    VALUE *sp;			/* cfp[1] */
    VALUE *bp;			/* cfp[2] */
    rb_iseq_t *iseq;		/* cfp[3] */
    VALUE flag;			/* cfp[4] */
    VALUE self;			/* cfp[5] / block[0] */
    VALUE *lfp;			/* cfp[6] / block[1] */
    VALUE *dfp;			/* cfp[7] / block[2] */
    rb_iseq_t *block_iseq;	/* cfp[8] / block[3] */
    VALUE proc;			/* cfp[9] / block[4] */
    ID method_id;               /* cfp[10] saved in special case */
    VALUE method_class;         /* cfp[11] saved in special case */
    VALUE prof_time_self;       /* cfp[12] */
    VALUE prof_time_chld;       /* cfp[13] */
} rb_control_frame_t;

control frame generally cref?

vm_core.h:293
typedef struct rb_iseq_struct rb_iseq_t;

vm_core.h:192
struct rb_iseq_struct {
    /***************/
    /* static data */
    /***************/

    VALUE type;          /* instruction sequence type */
    VALUE name;	         /* String: iseq name */
    VALUE filename;      /* file information where this sequence from */
    VALUE *iseq;         /* iseq (insn number and openrads) */
    VALUE *iseq_encoded; /* encoded iseq */
    unsigned long iseq_size;
    VALUE mark_ary;	/* Array: includes operands which should be GC marked */
    VALUE coverage;     /* coverage array */

    /* insn info, must be freed */
    struct iseq_insn_info_entry *insn_info_table;
    unsigned long insn_info_size;

    ID *local_table;		/* must free */
    int local_table_size;

    /* method, class frame: sizeof(vars) + 1, block frame: sizeof(vars) */
    int local_size; 

    /**
     * argument information
     *
     *  def m(a1, a2, ..., aM,                    # mandatory
     *        b1=(...), b2=(...), ..., bN=(...),  # optinal
     *        *c,                                 # rest
     *        d1, d2, ..., dO,                    # post
     *        &e)                                 # block
     * =>
     *
     *  argc           = M
     *  arg_rest       = M+N+1 // or -1 if no rest arg
     *  arg_opts       = N
     *  arg_opts_tbl   = [ (N entries) ]
     *  arg_post_len   = O // 0 if no post arguments
     *  arg_post_start = M+N+2
     *  arg_block      = M+N + 1 + O + 1 // -1 if no block arg
     *  arg_simple     = 0 if not simple arguments.
     *                 = 1 if no opt, rest, post, block.
     *                 = 2 if ambiguos block parameter ({|a|}).
     *  arg_size       = argument size.
     */

    int argc;
    int arg_simple;
    int arg_rest;
    int arg_block;
    int arg_opts;
    int arg_post_len;
    int arg_post_start;
    int arg_size;
    VALUE *arg_opt_table;

    int stack_max; /* for stack overflow check */

    /* catch table */
    struct iseq_catch_table_entry *catch_table;
    int catch_table_size;

    /* for child iseq */
    struct rb_iseq_struct *parent_iseq;
    struct rb_iseq_struct *local_iseq;

    /****************/
    /* dynamic data */
    /****************/

    VALUE self;
    VALUE orig;			/* non-NULL if its data have origin */

    /* block inlining */
    /* 
     * NODE *node;
     * void *special_block_builder;
     * void *cached_special_block_builder;
     * VALUE cached_special_block;
     */

    /* klass/module nest information stack (cref) */
    NODE *cref_stack;
    VALUE klass;

    /* misc */
    ID defined_method_id;	/* for define_method */
    rb_iseq_profile_t profile;

    /* used at compile time */
    struct iseq_compile_data *compile_data;
};

