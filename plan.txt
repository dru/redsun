
pretty print as3 so I can read it and understand what's happening
write some as3, compile it, and look at the output

translate basic ruby calls to as3
insert byte codes into existing abc_file
- have to search/update constant_pool - strings, multinames, namespaces

goals:
- enable code generation from Ruby to AS3 bytecode
-- implement methods and event handlers
-- shortcuts for properties and handling changes in commitProperties()
-- automatic xxChanged:boolean generation and callback in commitProperties() based on some convention
- enable tx of Flash vector definitions
-- transform vectors into Degrafa definitions
- transform fonts into Degrafa definitions
- pointcut expressions to modify existing methods

Awful things I don't want to think about:
* converting floating point numbers


New plans:

* Implement a bunch of AS3 to support Ruby
* Implement different send_external on Object.prototype and RObject.prototype
* Don't use AS3 classes to implement Ruby classes
* Ruby inheritance hierarchy implemented in plain AS3 to support proper semantics and method dispatch

Problems:
* How do you "subclass" Sprite; implement a Sprite object in Ruby if you cannot inherit from flash.display.Sprite?
* method for proxying a typed class? include_typed_class Flash::Display::Sprite


Const (and other) scoping issues:

Here's the code in question:

class A
  class B
    def d
      C
    end
  end
  class C
  end
end

b = A::B.new
b.d # returns A::C

How does this work? The :getconstant bytecode searches upwards in the scope
stack at the time of definition to find the constant. When I define classes
and methods, I'm not saving the scope stack currently so I don't know where
to search for the constant definition.

Solution: Obviously, the scope stack must be searched by this opcode and
others. Is there a way to call up the scope stack that is created by AVM2?

Looks like it is very hard to use the Flash call stack to look up this
information. Decent solution is to store the call stack at each level, but
where would this actually be stored? Then would local variables not really
be local variables in the AS3 version? It seems like we are getting further
and further away from a bytecode translater into a bytecode interpretter
at this point. Is this a good idea?

We have closures already in Flash, but do the opcodes for accessing closure
variables allow us to translate into something that can be used in AS3?
What are the opcodes in AS3 also?

10/8/2008

Moved test/files which are not used in tests to /research. This seems like
a more appropriate and descriptive name.

10/9/2008


"YARVInstructionSequence/SimpleDataFormat", 1, 1, 1,
{:arg_size=>1, :local_size=>5, :stack_max=>2},
"blah", "<compiled>",
:method,
[:parm1, :i, :i2, :ar],
1,
[
  [:break, nil, :label_32, :label_40, :label_40, 0],
  [:break, nil, :label_41, :label_49, :label_49, 0],
  [:break, nil, :label_50, :label_58, :label_58, 0],
]


10/14/2008

Migrating Red Sun work to new MacBook Pro. Authorizing github access and 
testing commit privileges. Installing Ruby 1.9.0-4, looking into mspec instead
of rspec.

Making new plan for conference deadline:

Focus on establishing baseline through generating as3. Accept the possibility
that storing stack information may be necessary fo lookups. May need a
structure for stack information. Use HotRuby as a guide. Get into the Ruby
source further and track down the execution of the bytecode.

Using anonymous functions as block scope might work. Pass the surrounding
blocks structure as a parameter to the function as in:

// root
function ():* {
  scope = new Scope();
  // blah
  function (upper:Scope):* {
    scope = new Scope(upper);
    // blah
    scope.getdynamic(/* ?? */);
  }();
}


10/15/2008

You cannot subclass Class:
>> class B < Class
>> end
TypeError: can't make subclass of Class
	from (irb):1
>> 

class.c:60
rb_class_new(VALUE super)
...
    if (super == rb_cClass) {
	rb_raise(rb_eTypeError, "can't make subclass of Class");
    }
...
}

10/16/2008

Further research into initialization and basic structures.
Have been reading through the Ruby Hacker's Guide.

Plan is to generate AS3 bytecode from Ruby bytecode that operates as an AS3
Ruby VM. Instead of interpretting the Ruby bytecode at runtime, the Ruby
project will translate the Ruby bytecode into AS3 bytecode that interacts
with the Ruby AS3 VM.

Renamed research files from *.txt to *.c to help Emacs highlight them better.
Probably a better way to convince Emacs to do that, but this is easy.

